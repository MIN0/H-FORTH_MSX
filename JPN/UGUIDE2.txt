−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
　　UGUIDE2.DOC　Ｈ−ＦＯＲＴＨ Ver1.4 ユーザーズガイド２
　　　　　　　　　【　　中　級　編　　】
　　Copyright(c) 1999 A.Hiramatsu（平松　明夫） 99/04/01
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

第２部　中級編

　第２部では、Ｈ−ＦＯＲＴＨの中で特にＭＳＸ用に特化された部分について述べま
す。


第１章　ネイティブコードコール

　Ｚ８０のマシン語ルーチンを呼び出す機能をネイティブコードコールと言います。
そのためのワードとして CALL BIOS BDOS の３つがあります。

　《呼びたい番地》 CALL で、現在のメモリマップ上で指定された番地をコールします。
　《呼びたいＢＩＯＳの番地》 BIOS でＢＩＯＳ（メインＲＯＭ）をコールします。

　《ファンクション番号》 BDOS でＤＯＳのファンクションコールを実行します。

　ネイティブコードコールを行う際に、ＣＰＵのレジスタの値を受け渡しするために、
以下のＣＰＵレジスタ変数と呼ばれるシステム変数が用意されています。

	_F  _A  _B  _C  _D  _E  _H  _L
	_BC  _DE  _HL  _IX  _IY

　これらの変数にＣＰＵに渡したい値を代入し、ネイティブコードコールを行うと、
その値がＣＰＵのレジスタにロードされて目的のルーチンが呼ばれます。そのルーチ
ンからリターンしてくるとそのときのＣＰＵのレジスタの値がこれらの変数に代入さ
れます。（ただし、 BIOS を使用する際には _IX と _IY は無効です。）

　_B _C と _BC 、_D _E と _DE 、_H _L と _HL は、同じアドレスに割り当てられ
ています。つまり、Ｃ言語でいうところの共用体になっています。たとえば、

	$12 >> _B  $34 >> _C

と、

	$1234 >> _BC

は結果は同じです。

　以下に例を挙げます。

	$4000 >> _HL  $24 CALL	ＨＬレジスタに $4000 を入れて、 $24番地をコー
				ルします。
				
	5 >> _A  $5F BIOS	Ａレジスタに５を入れてＢＩＯＳの $5F番地をコー
				ルします。
	
	$8000 >> _DE  $0F BDOS	ＤＥレジスタに $8000 を入れて、ＤＯＳのファン
	_A .			クションコール $0F番を実行します。実行後のＡレ
				ジスタの値を表示します。


　ＤＯＳのファンクションコールを使用する際に便利なワードとして CNVFCB があり
ます。これはファイル名をＤＯＳのＦＣＢ形式（ドライブ名１バイト＋ファイル名８
バイト＋拡張子３バイト）に変換するものです。
　ＤＯＳ２環境では必要ない機能ですが、ＭＳＸ２／２＋でＤＯＳ１、という環境の
人は決して少なくないと思います。

　このワードは

　　《変換元のファイル名》 《変換結果を転送する番地》 CNVFCB

と書いて使用します。ワイルドカード '*' は '?' に展開されます。実行後スタック
には変換に成功した文字数が積まれます。全く変換できなかった場合０が積まれます。

　変換に成功した／しないにかかわらず転送先の番地から１２バイトは書き換えられ
るので注意してください。

　以下に変換の例を挙げます。

例１	"ABC.TXT" $8000 CNVFCB
	
		↓
	
	8000  00 41 42 43 20 20 20 20 20 54 58 54
	      ~~ ~~~~~~~~~~~~~~~~~~~~~~~ ~~~~~~~~
	      ↑　ファイル名             拡張子
	      ドライブ番号（デフォルトドライブは０）
	実行後スタックには７（"ABC.TXT"の長さ）が積まれる


例２	"B:DEF*.BIN" $8000 CNVFCB
	
		↓
	
	8000  02 44 45 46 3F 3F 3F 3F 3F 42 49 4E
	      ~~ ~~~~~~~~~~~~~~~~~~~~~~~ ~~~~~~~~
              ↑  ↑                     拡張子
	      ｜　ファイル名（'*' が '?' ($3F) に展開されている）
	      ドライブ番号（Ｂドライブは２）
	実行後スタックには１０（"B:DEF*.BIN"の長さ）が積まれる


第２章　拡張コンソールルーチン

　Ｈ−ＦＯＲＴＨは、デフォルトでは文字の入出力をＢＩＯＳの CHGET ($9F) と
CHPUT ($A2) にて行っていますが、ユーザーが作ったルーチンを代わりに使うことが
できます。

　システム変数 _XCHGET と _XCHPUT にはデフォルトで０が入っていますが、ここに
ユーザーが作ったルーチンの開始番地を入れるとＢＩＯＳは呼ばれずにユーザーのル
ーチンが呼ばれます。
　応用例としてはグラフィック画面に文字を出力するなどが考えられます。

　ユーザールーチンは、１文字入力ルーチンは入力された文字コードをＡレジスタに
入れてリターン、１文字出力ルーチンはＡレジスタに入っていた文字コードを出力す
る、と言う仕様になっていればどんなルーチンでも構いません。
　レジスタの待避はＨ−ＦＯＲＴＨ側で行うので特に意識する必要はありません。

　以下に１文字出力をＢＩＯＳの代わりにＤＯＳのファンクションコールで行う例を
挙げます。

	: SET_BDOS_CHPUT
	DATA( BYTE:
		$5F		/* LD E,A */
		$0E $02		/* LD C,02H */
		$CD $05 $00	/* CALL 05H */
		$C9		/* RET */
	) DROP			/* バイト数はいらないので捨てる */
	>> _XCHPUT
	;
	
	: MAIN
	SET_BDOS_CHPUT		/* ユーザールーチンに切り換える */
	
	{
	    "\nOUTPUT BY BDOS." STR.
	}
	;
	END MAIN


第３章　Ｉ／Ｏポートアクセス

　Ｈ−ＦＯＲＴＨはＩ／Ｏポートを直接アクセスするワードを持っています。ＭＳＸ
規格ではＶＤＰ以外のＩ／Ｏポートアクセスは禁止されているので、Ｇ−ＦＯＲＴＨ
のときにはあえて付けなかったのせすが、ｔｕｒｂｏＲ以降アスキー自らそれをやぶ
りっており、また最近はハードの自作をする人が増えているので、自作ハードのドラ
イバなども作りやすいようにこれらを追加しました。

　　《書き込む値》 《Ｉ／Ｏポートアドレス》 P!

で書き込み、

　　《Ｉ／Ｏポートアドレス》 P@

で読み込みです。


第４章　ＶＤＰアクセス


「ページセレクタ」

　Ｈ−ＦＯＲＴＨにおいては、リードページ、ライトページ、ディスプレイページと
いう３つのページセレクタがあります。それぞれ、ＶＲＡＭを読むページ、ＶＲＡＭ
に書き込むページ、画面に表示するページを選択します。

　以下の３つのシステム変数がページセレクタです。

	_RPG		リードページ
	_WPG		ライトページ
	_DPG		ディスプレイページ

　リードページとライトページは、システム変数に代入しただけで有効になります。
ディスプレイページを切り換えるには、代入の後ワード SETDPG を実行することで切
り替わります。

　ページのサイズは、スクリーンモードによって違います。スクリーン６以下では１
ページ３２Ｋバイト、７以上では１ページ６４Ｋバイトです。なお、現在のスクリー
ンモードはＢＩＯＳのワークエリア SCRMOD($FCAF番地) から判断しています。

　スクリーン４以下では _DPG と SETDPG によるディスプレイページの切り換えはで
きません。必要ならＶＤＰレジスタを操作してください。

　以下に例を挙げます。

	5 >> _A  $5F BIOS	/* ＢＩＯＳコールでスクリーン５にする */
	3 >> _DPG  SETDPG	/* ページ３を表示 */
	3 >> _WPG		/* ライトページを３にする */
	$FF $1234 VC!		/* ページ３の $1234番地に $FF を書き込む */
				/* （ＶＲＡＭの絶対番地は $19234 ） */

	1 >> _RPG		/* リードページ（転送元ページ）を１にする */
	2 >> _WPG		/* ライトページ（転送先ページ）を２にする */
	10 >> _SX  20 >> _SY	/* 転送元開始座標＝( 10 , 20 ) */
	30 >> _NX  40 >> _NY	/* 矩形領域のサイズ＝( 30 , 40 ) */
	50 >> _DX  60 >> _DY	/* 転送先の座標＝( 50 , 60 ) */
	0 >> _LOG		/* ロジカルオペレーション＝PSET */
	LMMM			/* 転送実行 */


「ＶＤＰレジスタアクセス」

　ＶＤＰのレジスタに書き込むには、

　　《書き込む値》 《レジスタ番号》 VDP!

です。注意して欲しいのは，ＢＡＳＩＣの VDP( ) と違い、８番以降のレジスタ番号
がずれないことです。
　これで書き込んだ値はＢＩＯＳのワークエリアに保存されます。その値を読むには

　　《レジスタ番号》 VDP@

で行います。

　ＶＤＰのステータスレジスタを読むのは

　　《ステータスレジスタ番号》 VDPS@

です。

　パレットレジスタに書き込むのは

　　《パレットの値》 《パレット番号》 PAL!

です。《パレットの値》は、緑×２５６＋赤×１６＋青です。１６進で書いた方がわ
かりやすいでしょう。たとえば赤７、緑６、青４の肌色は $674 です。

　パレット全部を一挙に設定することもできます。

　　《パレットデータの番地》 SETPAL

で、メモリ上の《パレットデータの番地》から３２バイトがパレットレジスタに送ら
れます。


「ＶＲＡＭのアクセス」

　　《書き込む値》 《ＶＲＡＭの番地》 VC!

で１バイトの書き込み、

　　《書き込む値》 《ＶＲＡＭの番地》 V!

で２バイトの書き込みを行うことができます。

　　《ＶＲＡＭの番地》 VC@

で１バイトの読み込み、

　　《ＶＲＡＭの番地》 V@

で２バイトの読み込みを行うことができます。

　　《メモリの番地》 《バイト数》 《ＶＲＡＭの番地》 LDIRVM

でメモリからＶＲＡＭヘのブロック転送、

　　《ＶＲＡＭの番地》 《バイト数》 《メモリの番地》 LDIRMV

でＶＲＡＭからメモリへのブロック転送ができます。

　　《書き込む値》 《バイト数》 《ＶＲＡＭの番地》 FILVRM

でＶＲＡＭを同じ値で埋め尽くすことができます。


「垂直周期を待つ」

　　《待つ回数》 VSYNC

で指定回数垂直周期を待ちます。アクションゲームなどで垂直周期と同期をとるのに
も使えますし、単に適当な時間を経過させるのにも使えます。


「ＶＤＰコマンド」

　ＶＤＰコマンドを使うにはまず、以下のＶＤＰコマンド変数と呼ばれるシステム変
数に必要な値を代入します。これらの変数の値は、ＶＤＰコマンドワードを実行する
時に該当するＶＤＰのレジスタに書き込まれます。

	_SX	読みだし開始Ｘ座標	（ＶＤＰの R#32,33 に該当）
	_SY	読みだし開始Ｙ座標	（　〃　　 R#34,35 　〃　）
	_DX	書き込み開始Ｘ座標	（　〃　　 R#36,37 　〃　）
	_DY	書き込み開始Ｙ座標	（　〃　　 R#38,39 　〃　）
	_NX	Ｘ方向のドット数	（　〃　　 R#40,41 　〃　）
	_NY	Ｙ方向のドット数	（　〃　　 R#42,43 　〃　）
	_COL	書き込む色		（　〃　　 R#44    　〃　）
	_ARG	転送方向など		（　〃　　 R#45    　〃　）
	_LOG	ロジカルオペレーション	（　〃　　 R#46の下位４ビットに該当）

　_SY と _DY の値はそのままＶＤＰに書き込まれるのではなく、リードページとラ
イトページが影響します。具体的には _RPG を２５６倍した値が _SY に、_WPG を
２５６倍した値が _DY に加算されます。

　また、_ARG （R#45に該当）に代入した値が実際に有効になるのは SRCHコマンドの
みです。他のコマンドにおいては R#45 の値は _NX と _NY の符号と大小関係から自
動的に決まるので設定の必要はありません。
　SRCH 以外のコマンドにおいては _NX の値が負なら、R#45 のビット２（DIX）がセ
ットされます。_NY の値が負ならビット３（DIY）がセットされます。また、_NY の
絶対値が _NX の絶対値より大きいか等しい場合ビット０（MAJ）がセットされます。

　ＶＤＰコマンド変数は上記の順序でメモリ上で連続していることが保証されていま
す。したがって DATA( ) と MEMMOVE によって一挙に設定することも可能です。以下
に例を挙げます。

	DATA( INT:
		  0    0	/* _SX , _SY */
		128  100	/* _DX , _DY */
		 64   64	/* _NX , _NY */
	      BYTE:
	          0		/* _COL */
	          0		/* _ARG */
	          0		/* _LOG */
	) & _SX MEMMOVE		/* _SX の番地以降に転送 */


　ＶＤＰコマンドワードには以下のものがあります。

	LMMC	メモリからＶＲＡＭへの論理矩形転送（スクリーン５、７用）※1
	LMCM	ＶＲＡＭからメモリへの論理矩形転送（スクリーン５、７用）※1
	LMMC8	メモリからＶＲＡＭヘの論理矩形転送（スクリーン８以上用）※1
	LMCM8	ＶＲＡＭからメモリへの論理矩形転送（スクリーン８以上用）※1
	LMMM	ＶＲＡＭ上での論理矩形転送
	LMMV	ＶＲＡＭ上での論理矩形塗り潰し
	HMMC	メモリからＶＲＡＭへの高速矩形転送※1
	HMMM	ＶＲＡＭ上での高速矩形転送
	HMMV	ＶＲＡＭ上での高速矩形塗り潰し
	LINE	直線描画
	PSET	点描画
	POINT	指定点の色を調べる※2
	SRCH	指定色を水平にサーチ※2

　※1 がついたワードはメモリの番地をスタックから与えます。また、※2 がついた
ワードは実行結果がスタックに置かれます。

　以下にＶＤＰコマンドの例を挙げます。

	200 >> _DX  100 >> _DY		/* 書き込み開始点 */
	-128 >> _NX			/* Ｘ方向の長さ */
	-64  >> _NY			/* Ｙ方向の長さ */
	15  >> _COL			/* 色コード＝１５ */
	0   >> _LOG			/* ロジカルオペレーション=PSET */
	LINE

　この例は、ＢＡＳＩＣで LINE(200,100)-STEP(-127,-63),15 を実行したのと同じ
です。ちょっと注意が必要なのはＢＡＳＩＣの STEP() は座標値の差を指定するのに
対し、 _NX _NY に設定するのは描かれるドット数であることです。つまり _NX _NY 
に設定する値の絶対値は STEP() より１多くなります。

	0 >> _DX  0 >> _DY		/* 書き込み開始点 */
	64 >> _NX  64 >> _NY		/* 転送量＝６４×６４ドット */
	8 >> _LOG			/* ロジカルオペレーション=TPSET */
	$8000  LMMC			/* 転送元番地は $8000 、転送実行 */

　この例ではメモリの $8000番地以降にあるデータをＶＲＡＭ上の (0,0)-(63,63) 
の矩形領域に転送します。ＢＡＳＩＣの COPY 《配列》 TO (《座標》) に相当する
と思えばよいでしょう。

	128 >> _SX  100 >> _SY		/* サーチ開始点 */
	10 >> _COL			/* 探す色コード=10 */
	0  >> _ARG			/* 探す方向は右、サーチモードは０ */
	SRCH >> POSX			/* サーチ実行、結果を POSX に代入 */

　この例では (128,100) から色コード 10 を右に向かって探します。ワード SRCH 
は指定色が見つかった場合そのＸ座標をスタックに置きます。見つからなかった場合
-1 を置きます。
　_ARG に設定する値はビット２が探す方向（０＝右、１＝左）で、ビット１はサー
チモード（０＝指定色を探す、１＝指定色以外を探す）です。


　ＶＤＰコマンドワードは、_SY、_DY、_ARG などに若干手が加わる他は、ほとんど
裸のＶＤＰ操作であると言えます。したがってＶＤＰそのものを理解していないと十
分に使いこなせません。
　このドキュメントはＶＤＰの解説書ではないので、ＶＤＰそのものの説明は控えさ
せていただきます。
　ＶＤＰそのものの機能に付いてはＭＳＸ−Ｄａｔａｐａｃｋなどの解説書をよく読
むことをお薦めします。


第５章　拡張ランタイムライブラリ

　Ｈ−ＦＯＲＴＨは、拡張ランタイムライブラリによりその機能を拡張することがで
きます。「拡張ランタイムライブラリ」なんて仰々しい名前がついてますが、大した
ことはありません。リロケート可能なマシン語ファイルのフォーマットを定めただけ
です。

　長ったらしいので以後、拡張ランタイムライブラリのことをＸＲＬと呼びます。

　残念ながら現時点ではＸＲＬはＨ−ＦＯＲＴＨでは作れません。すべてアセンブラ
で作成します。

　ＸＲＬの基本的な使い方は、ＸＲＬのファイルをＤＯＳのファンクションコールで
ユーザーフリーエリアにロードし、ワード RELOCATE でリロケートします。そしてＸ
ＲＬ内のマシン語ルーチンを CALL で呼んで使います。

　ＸＲＬはリロケート可能なのでユーザーフリーエリアの先頭番地が変動しても影響
を受けません。（もちろんＸＲＬのファイルサイズよりフリーエリアが広いことが大
前提ですが。）


「ＸＲＬファイルを作る」

　ＸＲＬファイルのフォーマットは以下のようになっています。

ｵﾌｾｯﾄ	  ｻｲｽﾞ	  名称		内容

0	  2	  XRLID   ファイルＩＤ $58,$52 （"XR" の文字コード）
2	  2	  ROFS	  リロケーションテーブルのオフセット
4	  可変長  XRLBDY  ＸＲＬのマシン語ルーチン本体
ROFS	  2	  ORGLOC  リロケート前の、本来のアドレス
ROFS+2	  可変長  RLCENT  リロケーションエントリ（総バイト数を n とする）
ROFS+2+n  2	  ENDRLC  $0000 、リロケーションテーブルの終わりを表す

　最初の４バイトをヘッダ、XRLBDY の部分をボディ、ORGLOC 以降をリロケーション
テーブルと呼びます。

　例として、ＰＳＧのレジスタアクセスを行うＸＲＬのアセンブラリストを示します。
（言うまでもなく、こんなのはわざわざＸＲＬにしなくても BIOS で呼べばいいので
すが、ＸＲＬの題材として簡単なものを選びました。）
--------------------------------------------------------------- PSG.MAC ---

	ASEG
	ORG	0100H

XRLID:	DB	'XR'
ROFS:	DW	ORGLOC-0100H	; 0100H番地からのオフセット

; −−−　ここからボディ、すなわちマシン語ルーチンの本体　−−−

XRLBDY:			; 別にこんなラベルつけなくても良いのですが(^^;

REGSEL:	DB	0	; Ｈ−ＦＯＲＴＨとデータのやり取りを行う領域
REGDAT:	DB	0	; 同上

RDPSG:
RL0001:	JP	XRDPSG	; Ｈ−ＦＯＲＴＨからのコールの入り口
WRPSG:
RL0002:	JP	XWRPSG	; 同上

; 以上のように、データをやり取りする領域と、コールの入り口はボディの最初の方
; にまとめて置くのが賢明です。マシン語ルーチンのバージョンが変わってもＨ−Ｆ
; ＯＲＴＨ側のプログラムは直さずに済みます。

XRDPSG:
RL0003:	LD	A,(REGSEL)	; レジスタ番号
	LD	IX,096H		; ＢＩＯＳのＲＤＰＳＧの番地
	LD	IY,(0FCC0H)	; メインＲＯＭのスロット
	CALL	01CH		; インタースロットコール
RL0004:	LD	(REGDAT),A	; 結果
	RET

XWRPSG:
RL0005:	LD	A,(REGDAT)	; 書き込むデータ
	LD	E,A
RL0006:	LD	A,(REGSEL)	; レジスタ番号
	LD	IX,093H		; ＢＩＯＳのＷＲＴＰＳＧの番地
	LD	IY,(0FCC0H)	; メインＲＯＭのスロット
	CALL	01CH		; インタースロットコール
	RET

; −−−　ここからがリロケーションテーブル　−−−

ORGLOC:	DW	0100H		; 本来のアドレス、これも 0100H が起点

RLCENT:	DW	RL0001+1	; リロケーションエントリです。
	DW	RL0002+1	; リロケートすべき番地を列挙します。
	DW	RL0003+1	; ジャンプ、ロード命令などのオペランド
	DW	RL0004+1	; 部分の番地です。
	DW	RL0005+1
	DW	RL0006+1
ENDRLC:	DW	0		; リロケーションテーブルの終わりです。
				; 0 が終わりを表しますからリロケーション
				; エントリの中に 0 は使えません。

	END

----------------------------------------------------------------------------

　これをアセンブルするのにＭ８０とＬ８０を使うならＤＯＳのコマンドラインから

	M80 =PSG/r
	L80 PSG,PSG/n/e

とします。作成したＣＯＭファイルの拡張子を .XRL にリネームしておきます。

　このＸＲＬの使い方の例は次の章の最後の例題に挙げます。


「システム変数の番地」

　以下のシステム変数は番地が決まっており、今後Ｈ−ＦＯＲＴＨのバージョンが変
わっても変化しないことが保証されています。よってＸＲＬなど、ユーザーが作成し
たマシン語ルーチンの中から参照できます。

$0106	_FREE
$0108	_ENDFREE
$010A	_F
$010B	_A
$010C	_C  _BC
$010D	_B
$010E	_E  _DE
$010F	_D
$0110	_L  _HL
$0111	_H
$0112	_IX
$0114	_IY
$0116	_RPG
$0117	_WPG
$0118	_DPG
$0119	_SX
$011B	_SY
$011D	_DX
$011F	_DY
$0121	_NX
$0123	_NY
$0125	_COL
$0126	_ARG
$0127	_LOG
$0128	_XCHGET
$012A	_XCHPUT

　また、$0104、$0105番地にはメインＲＯＭの６、７番地から読み込んだＶＤＰのア
ドレスが入っています。ＶＤＰを直接操作する場合、わざわざメインＲＯＭを読まな
くてもここの値を使えば済みます。


第６章　第２部のまとめ

　例題プログラムを３つほど挙げます。まずはＤＯＳの TYPE コマンドとほぼ同じ働
きをする NTYPE.COM を作ってみます。
　コンパイル後、NTYPE 《ファイル名》 で使えます。
------------------------------------------------------------- NTYPE.4TH ---
4096 CONST>> BUFSIZE		/* バッファのサイズ＝４０９６バイト */
$5C CONST>> &FCB		/* ＤＯＳが用意しているＦＣＢ */

ARRAY( BYTE: BUFFER 0 )		/* バッファを可変配列としてとる */

/* −−−　バッファの先頭から N文字表示するワード　−−− */

: NCHPUT  PARAM( N )		/* パラメータは N */
VAR( I )			/* ローカル変数 */

0 >> I				/* I の初期値は０（バッファの先頭） */
WHILE( I N < ){			/* I<N の間くり返し */
    BUFFER [ I ] CHPUT		/* BUFFER の I 番目を出力 */
    I 1 + >> I			/* I に１を足す */
} ;

/* −−−　メインワード　−−− */

: MAIN

_FREE BUFSIZE ARRAY>> BUFFER		/* 可変配列の番地、サイズを指定 */

0 ( &FCB 12 + ) !			/* カレントブロックをリセット */
&FCB >> _DE $0F BDOS			/* ファイルオープン */
_A IF{					/* Ａが０でなければ失敗 */
    "FILE NOT FOUND" ERROR		/* エラー表示して終了 */
}
1 ( &FCB 14 + ) !			/* レコードサイズ＝１バイト */
0 ( &FCB 33 + ) ! 0 ( &FCB 35 + ) !	/* レコードポジション＝０ */

{					/* ループ始め */
    & BUFFER >> _DE $1A BDOS		/* ＤＴＡを BUFFER の先頭に設定 */

    &FCB >> _DE  BUFSIZE >> _HL
    $27 BDOS				/* １ブロック読み込み */

    _A IF{				/* Ａが０でない場合 */
        _HL NCHPUT			/* ＨＬ＝有効な文字数だけ出力 */
        BREAK				/* ループを抜ける */

    }{					/* Ａが０の場合 */
        BUFSIZE NCHPUT			/* バッファの文字を全部出力 */
    }
}					/* くり返し */
;
END MAIN
--------------------------------------------------------------------------

　次の例題はグラフィックのデモです。止めたくなったらＣＴＲＬ−ＳＴＯＰを押
します。
------------------------------------------------------------- LINE.4TH ---
ARRAY( INT: PALETTE 0 )		/* パレット用可変配列 */

/* −−−　画面にいっぱい線を引くワード　−−− */

: DRAW
VAR( X Y C )

0 >> C				/* C の初期値 */
0 >> Y				/* Y の初期値 */
WHILE( Y 212 < ){		/* Y<212 の間くりかえし */
    0 >> _DX    0 >> _DY	/* 描画開始点 */
    256 >> _NX  Y >> _NY	/* Ｘ，Ｙの描画する長さ */
    C 8 + >> _COL		/* 色は C+8 、つまり8〜15*/
    0 >> _LOG			/* ロジカルオペレーション＝PSET */
    LINE			/* 線を引く */
    
    C 1 + 7 AND >> C		/* C に１を足して 7 で AND する */
    Y 2 + >> Y			/* Y に２を足す */
}

254 >> X			/* X の初期値 */
WHILE( X 0 >= ){		/* X>=0 の間くりかえし */
    0 >> _DX    0 >> _DY	/* 描画開始点 */
    X >> _NX  212 >> _NY	/* Ｘ，Ｙの描画する長さ */
    C 8 + >> _COL		/* 色は C+8 、つまり8〜15*/
    0 >> _LOG			/* ロジカルオペレーション＝PSET */
    LINE			/* 線を引く */
    
    C 1 + 7 AND >> C		/* C に１を足して 7 で AND する */
    X 2 - >> X			/* X から２を引く */
} ;

/* −−−　メインワード　−−− */

: MAIN
VAR( I P )

5 >> _A  $5F BIOS		/* スクリーン５にする */

DATA( INT:
    0 0 0 0 0 0 0 0		/* 0〜7番のパレット */
    $700 $701 $602 $503		/* 8〜11番のパレット */
    $404 $305 $206 $107		/* 12〜15番のパレット */
) ARRAY>> PALETTE		/* これをそのまま可変配列にする */

& PALETTE SETPAL		/* パレット設定 */
DRAW				/* 描画 */

{
    PALETTE [ 8 ] >> P		/* パレット８番を P に保存 */
    8 >> I			/* I の初期値 8 */
    WHILE( I 15 < ){
        PALETTE [ I 1 + ]	/* I+1番を */
        >> PALETTE [ I ]	/* I番に移す */
        I 1 + >> I
    }
    P >> PALETTE [ 15 ]		/* ８番のパレットを１５番に移す */
    
    5 VSYNC			/* 適当に時間をつぶす */
    
    & PALETTE SETPAL		/* 新しいパレットを設定 */
}
;
END MAIN
--------------------------------------------------------------------------

　最後の例題は第５章で作った PSG.XRL を使用する例です。
---------------------------------------------------------- XRLTEST.4TH ---
VAR( XRLTOP )
ARRAY( BYTE: FCB 37 )

/* −−−　ＸＲＬをロードするワード　−−− */

: LOADXRL
VAR( FILESIZE NEWFREE )
"PSG.XRL" & FCB CNVFCB			/* ＦＣＢに名前を設定 */
DROP					/* 変換結果はいらないので捨てる */

0 ( & FCB 12 + ) !			/* カレントブロックをリセット */
& FCB >> _DE $0F BDOS			/* ファイルオープン */
_A IF{					/* Ａが０でなければ失敗 */
    "FILE NOT FOUND" ERROR		/* エラー表示して終了 */
}

( & FCB 16 + @ ) >> FILESIZE		/* ファイルサイズの下位２バイト */

( & FCB 18 + @ ) 0 <> 			/* ファイルサイズ上位が０でないか */
FILESIZE ( _ENDFREE _FREE - ) _>	/* 下位がフリーエリアより大きければ */
OR IF{
    "FILE TOO LARGE" ERROR		/* エラー表示して終了 */
}

1 ( & FCB 14 + ) !			/* レコードサイズ＝１バイト */
0 ( & FCB 33 + ) ! 0 ( & FCB 35 + ) !	/* レコードポジション＝０ */

_FREE >> _DE $1A BDOS			/* ＤＴＡをフリーエリアの先頭に設定 */

& FCB >> _DE  FILESIZE >> _HL  $27 BDOS	/* 読み込み実行 */

_FREE >> XRLTOP				/* ロードされたＸＲＬの先頭番地 */

( XRLTOP 2 + ) @ XRLTOP + >> NEWFREE	/* リロケート後はリロケーション */
					/* テーブルはいらなくなるので。 */

XRLTOP RELOCATE				/* リロケートを実行 */

NEWFREE >> _FREE			/* _FREE を設定しなおす */

/* 今回の例では関係ありませんが、ＸＲＬのボディが可変配列などで破壊されるの
   を防ぐため、ロード後は _FREE を設定しなおすことをお薦めします。 */

;

/* −−−　ＸＲＬを呼ぶワード　−−− */

: PSG@  PARAM( N )

N ( XRLTOP 4 + ) C!		/* REGSEL に N を書き込む */
( XRLTOP 6 + ) CALL		/* RDPSG を呼び出す */
( XRLTOP 5 + ) C@		/* REGDAT を読みだす */
;

: PSG!  PARAM( D N )

N ( XRLTOP 4 + ) C!		/* REGSEL に N を書き込む */
D ( XRLTOP 5 + ) C!		/* REGDAT に D を書き込む */
( XRLTOP 9 + ) CALL		/* WRTPSG を呼び出す */
;

/* −−−　メインワード　−−− */

: MAIN
VAR( I F )

LOADXRL				/* ＸＲＬをロード */

$BE 7 PSG!			/* チャネル１、矩形波のみＯＮ */
 12 8 PSG!			/* チャネル１、ボリューム＝１２ */

0 >> I
WHILE( I 5 < ){			/* ５回くり返し */
    100 >> F
    WHILE( F 300 < ){
        ( F 255 AND ) 0 PSG!	/* 分周比の下位を設定 */
        ( F 256 _/  ) 1 PSG!	/* 分周比の上位を設定 */

        1 VSYNC			/* 垂直周期を１回待つ（1/60秒） */

        F 1 + >> F
    }
    I 1 + >> I
}

  0 8 PSG!			/* チャネル１、ボリューム＝０ */
$BF 7 PSG!			/* 全チャネル発音停止 */
;
END MAIN
---------------------------------------------------------------------------

