−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
　　UGUIDE1.DOC　Ｈ−ＦＯＲＴＨ Ver1.4 ユーザーズガイド１
　　　　　　　　　【　　導　入　編　　】
　　Copyright(c) 1999 A.Hiramatsu（平松　明夫） 99/04/01
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

第１部　導入編

第１章　ようこそＦＯＲＴＨの世界へ

「ＦＯＲＴＨってなんだ？」

　ＦＯＲＴＨというのは、プログラミング言語の一つで、最初にムーアという人が作
ったそうです。ムーアさんは本当は「第４世代の言語」という意味でＦＯＵＲＴＨと
いう名前にしたかったそうですが、アセンブラの文字数の制限でＦＯＲＴＨになった
そうです。
　その後ごく一部（本当にごく一部(^^; ）の言語ヲタクに熱狂的に支持されて今日
までしぶとく（失礼(^^;）生き残っております。
　ＭＳ−ＤＯＳ用のソフトで「ＭＩＮＤ」という言語がありますが、それもＦＯＲＴ
Ｈ系の言語です。他に「ＦＩＦＴＨ」というのもあって、そちらの方がＦＯＲＴＨの
正当後継者らしいですがあまり話題にならず、どんな感じの言語なのか私もよくわか
りません。

　さて、Ｈ−ＦＯＲＴＨですが、これは私が作った新しいＦＯＲＴＨ系の言語です。
すでに本来のＦＯＲＴＨとは違ってしまった部分も結構あるのですが、逆ポーランド
記法を使っている限りやはりＦＯＲＴＨ系の言語であると考えています。

　ＭＳＸ用のＦＯＲＴＨ系言語としては、他に「Ｇ−ＦＯＲＴＨ」というフリーソフ
トがありますが、あれも実は私が作りました。私が「ＧＵＮＤＯＨ」というハンドル
ネームを使っていたころの作品です。
　Ｈ−ＦＯＲＴＨは、Ｇ−ＦＯＲＴＨとのソース互換性はありません。Ｇ−ＦＯＲＴ
Ｈで「これはちょっと使いにくいな」と感じた点について、言語仕様を変えているか
らです。
　また、プログラムの内部構造も全く別物と言っていいほど違います。あたかも旧日
本海軍の「紫電改」が「紫電」とは全く別物であったのと似ています。（そんな話、
だれもわかんないってば(^^;;;）


「逆ポーランド記法」

　ＦＯＲＴＨ系の言語の最大の特徴はなんといっても「逆ポーランド記法」です。

　逆ポーランド記法というのは数式の書き方の１つで、演算子が数値の後ろに来るた
め「後置記法」とも呼ばれます。ふだん私たちが書いている書き方は、演算子を数値
と数値の中間に書くため、「中置記法」と呼ばれます。

　たとえば、ふだん私たちが

 	A+5

と書いている数式は、逆ポーランド記法だと

 	A 5 +

と書きます。一見異様に見えますが、そのまま「Ａと５を足す」と読めば、決して難
解ではないことに気がつくと思います。

	(X-10)*(Y-20)

を逆ポーランド記法になおすと、

	X 10 - Y 20 - *

となります。これでわかりにくいなら

	( X 10 - ) ( Y 20 - ) *

と書けばわかりやすくなります。ようするに「Ｘから１０を引いた値」と「Ｙから２
０を引いた値」を掛けるのです。

　ちなみに、Ｈ−ＦＯＲＴＨでは条件判断の式も逆ポーランド記法で書きます。たと
えば普通の書き方で

	A>10

と書く条件式は逆ポーランド記法なら

	A 10 >

です。「Ａが１０より大きい」と読めばよいのですからそんなに難しくないですよね。

　こういった条件式の値は、条件が成立していれば１、成立していなければ０です。


「スタック」

　逆ポーランド記法を理解するカギは「スタック」にあります。

　スタックはほとんどのＣＰＵに付いていますが、大抵１つですよね。ＦＯＲＴＨに
は２つのスタックがあります。
　ＦＯＲＴＨは、「パラメータスタック」と「リターンスタック」の２つのスタック
をもつ仮想ＣＰＵのアセンブラだと思うと理解しやすいです。（実際、ムーアさんは
そういうＣＰＵも開発したらしいです。）

　リターンスタックの方が普通のＣＰＵのスタックに相当し、パラメータスタックは、
あえてたとえるとすればアキュムレータに相当します。計算はすべてパラメータスタ
ックの上で行うのです。
　ＦＯＲＴＨにおいては、パラメータスタックのほうが主役で、リターンスタックは
裏方です。プログラミングにおいてリターンスタックを意識することはほとんどあり
ません。今後単に「スタック」と言った場合パラメータスタックのことです。

　スタックは別名「ＦＩＬＯ」（First In Last Out、先入れ後出し）とも呼ばれま
す。イメージとしては、本や雑誌を平積みにしたような感じです。そして、スタック
に対しては「一番上にさらに何かを積む」か、「一番上のものを取り出す」という２
つの操作のみが許されているものとします。
　一番最初にスタックに積んだものは、その後から積み上げたものを全部取り去らな
ければ取り出すことができません。だからＦＩＬＯと呼ばれるのですね。

　Ｈ−ＦＯＲＴＨにおいては、スタックに積むことができるのは２バイトサイズの数
値です。数値をスタックに積むには、ソースプログラム上で単に数値を羅列すればよ
いのです。たとえば、

	5 200 16384

と書けば、スタックには５、２００、１６３８４の順で積まれます。この時点でスタ
ックの一番底は５、真ん中が２００、一番上が１６３８４となっています。ちなみに、
スタックの一番底を「ボトム」、一番上を「トップ」と言います。

　スタックから数値を取り出す方法はいろいろあるのですが、一番わかりやすい . で
説明します。 . は、スタックから１つ数値を取り出し、それを画面に表示する命令
（ワード）です。

	5 200 16384 . . .

と書くと、実行時には

	16384 200 5

と画面に表示されるはずです。なぜ順番が逆になるのかは、「先入れ後出し」という
ことを思い出してもらえば理解できると思います。一番最初の . でスタックから取
り出されるのは一番最後に積んだ１６３８４なのです。

　今度は簡単な計算を例にとります。３と４を足してその結果を表示することにしま
す。その場合、ソースプログラムには

	3 4 + .

と書きます。最初の 3 4 で、スタックに３、４の順に数値が積まれます。次の + で
以下のような事が起こります。

１）　まずスタックから１つ数値が取り出される（この場合は４）
２）　続いてもう１つ数値が取り出される（この場合は３）
３）　そしてその合計（この場合は７）がスタックに積まれる

　つまり、 + を実行し終わった時点で、３と４はスタックから消え、７がスタック
に残ります。次の . でスタックから７が取り出され、画面に表示されます。

　+ や . は、能動ワードといいます。これに対し、3 とか 4 とか 16384 とか、あ
るいは後に述べる定数や変数は数値ワードと呼ばれます。
　数値ワードは「スタックに積まれるワード」であり、能動ワードは「スタックに何
かするワード」なのです。他の言語において命令とか関数とか演算子とか呼ばれてい
るものに相当するのが能動ワードだと思えばよいでしょう。


「Ｈ−ＦＯＲＴＨのソースプログラム」

　Ｈ−ＦＯＲＴＨのソースプログラムは、ワードを半角スペース、タブ、改行などの
区切り文字で区切って記述します。厳密に言うと、区切り文字とは文字コードが１６
進数で $20 以下の文字のことです。

　区切り文字の書き方の差異がプログラムの論理的構造に影響することはありません。
たとえば、

	A 10 < IF{ FUNC_1 }{ FUNC_2 }

と書いても、

	A
	10
	<
	IF{
		FUNC_1
	}{
		FUNC_2
	}

と書いてもコンパイラは同じマシン語を出します。ＢＡＳＩＣのような、「 IF は行
末までしか有効にならない」みたいな制限はありません。

　ソースプログラム中に注釈を入れる場合は /* と */ で囲みます（ /* と */ の前
後には区切り文字が必要です）。その部分はプログラムの動作に関係ありません。注
釈のネスティングはできません。


「ワード」

　ワードとは、区切り文字以外の文字からなる文字の塊です。
ダブルクオート（文字コード $22）は区切り文字ではありませんが特別あつかいとな
っており、文字列定数ワードの最初と最後にしか使えません。

　ワードの文字数は、半角で３１文字を越えてはいけません。ただし、文字列定数ワ
ードはこの限りではありません。

　ユーザーは定義済みのワードを組み合わせて新しいワードを定義することができま
す。というか、それこそがＦＯＲＴＨのプログラミングの本質であると考えてよいで
しょう。

　ユーザーがワードを定義すると、その新しいワードはすでにシステムで定義されて
いるワードと同様に扱うことができます。

　ワードは基本的に１つのプログラムで一度しか定義できません。新しいワードを作
る時に既に同じ名前のワードが存在していたらエラーになります。（変数については
ローカル変数という例外があります。）
　また、新しいワードを定義する時、定義していないワードを定義内容の中に使うこ
とはできません。ただし、即値ワードは使えます。

　ワードは以下のような種類があります。詳しくは次章以降で説明します。

	種類					例

・数値ワード
　　・即値ワード
　　　　・数値定数　　　　		9999  -32768  $FCC1  -$ABCD
　　　　・文字定数			'A'  'BC'  '漢'
　　　　・文字列定数			"Hello World."
　
　　・名前付き数値ワード
　　　　・定数
　　　　　　・システム定義済み定数	TRUE  FALSE
　　　　　　・ユーザー定義定数

　　　　・変数
　　　　　　・システム変数		_FREE  _HL
　　　　　　・ユーザー定義変数
　　　　　　　　・単純変数
　　　　　　　　・配列変数
　　　　　　　　　　・固定配列（整数型およびバイト型）
　　　　　　　　　　・可変配列（整数型およびバイト型）
　　　　　　・外部変数（整数型およびバイト型）

・能動ワード
　　・被コンパイルワード
　　　　・システム定義済みワード	+  -  *  /  .
　　　　・ユーザー定義ワード
　　・変数操作ワード			>>  ARRAY>>
　　・コンパイラ制御ワード
　　　　・定義系ワード			:  VAR(  CONST>>  END
　　　　・コンパイルスイッチ		BREAKON  STKCHKON
　　　　・定数データ列			DATA(
　　　　・その他			(  )  [  ]  INT:  BYTE:
　　・実行制御ワード
　　　　・分岐構文			IF{
　　　　・ループ構文			WHILE(
　　　　・ループ構文補助ワード		BREAK  CONTINUE


第２章　数値ワード

「即値ワード」

　即値ワードは、スタックに積まれる数値そのものを表わします。即値ワードは定義
しなくても使えます。というか、基本的に即値ワードには「定義」ということ自体が
ありません。
　即値ワードはさらに数値定数、文字定数、文字列定数に分類されます。

　数値定数には１０進数と１６進数が使えます。１６進の場合は頭に $ を付けます。
数値は半角数字で書いてください。全角数字は数字と見なされません。
　１０進、１６進いずれの場合でも、さらに頭に - を付けることによって負の数にす
ることもできます。

　数値は２バイトで処理しています。扱える範囲は符号付き数値なら -32768〜32767、
符号無し数値なら 0〜65535です。数値自身は自分が符号付きなのか符号無しなのかを
知りません。それは数値に作用する能動ワードによって決まります。以下に同じ数値
を符号付き、符号無しとして扱った例を挙げます。

	-32768 2 /	結果: -16384	（符号付き数値として扱った場合）

	-32768 2 _/	結果: 16384	（符号無し数値として扱った場合）


　文字定数は半角文字１文字、または２文字を ' で囲ったもので、その文字コード
がスタックに積まれます。２文字の場合は最初の文字が下位バイト、２文字めが上位
バイトとなります。
　全角１文字を ' で囲った場合、上下バイトが入れ替わったシフトＪＩＳコードが
得られますが、あまり意味はないでしょう。


　文字列定数は文字列を " で囲ったもので、スタックにはその文字列の先頭番地が
積まれます。
　コンパイルされたＣＯＭファイルの中では文字列の最後に文字コード０が付加され
ています。Ｈ−ＦＯＲＴＨの文字列関係の能動ワードは、この文字コード０を文字列
の終わりと見なします。

　文字列定数ワードに関しては例外的に長さの制限はありません。また、途中に半角
スペースを含むことができます。

　文字列中に、Ｃ言語類似のエスケープシーケンスを入れることもできます。 \n で
改行、 \t でタブ、 \0 で文字コード０、\$ に続く１６進数２桁で文字コードの直
接指定となります。
 \ そのものを表わしたい時は \\ とします。

　プログラムリストを見やすくするため、あるいは使用しているテキストエディタに
行あたりの文字数制限がある、などの理由で長い文字列の途中で改行したい場合、い
ったん文字列を "- で切って次の行に残りの文字列を続ければそれは１つの長い文字
列であると見なされます。 "- による文字列の分割は何度でもできます。

例	"This is a very long long string."

		↓

	"This is a very "-
	"long long string."


「定数」（名前付き数値ワード）

　定数は特定の数値にワード名を付けたもので、その値は実行中に変化することはあ
りません。いったん定義してしまえば即値ワードと同様に使えます。
　また、すでにシステムで定義済みの定数して TRUE と FALSE があり、それぞれの
値は１と０です。

　ユーザーが定数を定義するには以下のようにします。

　　《値を表す式》 CONST>> 《定数名》

以下に例を挙げます。

	$FD9F CONST>> H.TIMI

	20 CONST>> ARRAY_X
	10 CONST>> ARRAY_Y
	ARRAY_X ARRAY_Y * CONST>> ARRAY_SIZE


「変数」

　変数は実行中にその値を変えることができる数値ワードで、システム変数とユーザ
ー変数と外部変数があります。

・システム変数は現在のシステムの状態を知るためや、マシン語ルーチンを呼んだり
ＶＤＰコマンドを使用したりするときデータを受け渡すために使います。

・ユーザー変数はさらに単純変数と配列変数に分かれます。
　　・単純変数はワード名１つにつき、整数型（２バイトサイズ）の値を１個、保持
　　　することができます。
　　・配列変数はワード名１つにつき、整数型またはバイト型（１バイトサイズ）の
　　　値を複数個保持することができます。

・外部変数はＨ−ＦＯＲＴＨ外部のメモリをあたかもＨ−ＦＯＲＴＨの変数であるか
のように扱えるようにするものです。これにより、たとえばＢＩＯＳのワークエリア
などが簡単にアクセスできます。


　変数に値を代入するには、

　　《代入したい値を表す式》 >> 《変数名》

です。ただし配列変数の場合は

　　《代入したい値を表す式》 >> 《変数名》 [ 《インデックス番号を表す式》 ]

です。インデックス番号は０をベースとします。たとえば要素数が５個の配列ならイ
ンデックス番号として０〜４までが使えます。

　変数の値をスタックに積むにはシステム変数、単純変数、外部変数なら変数名を書
くだけです。配列変数なら

　　《変数名》 [ 《インデックス番号を表す式》 ]

です。


「ユーザー変数の宣言」

　ユーザー変数は、前もって宣言しなければ使えません。単純変数は以下のように宣
言します。

　　VAR( 《変数名並び》 )

《変数名並び》には使いたい変数名を区切り文字で区切って列挙します。

　配列変数は以下のように宣言します。

　　ARRAY( 《タイプ》 《名前と要素数の並び》 )

と書きます。《タイプ》は整数型なら INT: 、バイト型なら BYTE: です。《名前と
要素数の並び》は、

　　《変数名１》 《変数名１の要素数》 《変数名２》 《変数名２の要素数》・・・

のように書きます。要素数の指定には文字列以外の即値ワードか、 CONST>> で定義
した定数のみが使えます。以下に例を挙げます。

	ARRAY( INT:  A 10   B 20 )

	256 CONST>> BUF_SIZE  37 CONST>> FCB_SIZE
	ARRAY( BYTE: BUFFER BUF_SIZE   FCB FCB_SIZE )

	ARRAY( BYTE: C1 32  C2 32   INT: N1 16  N2 100 )

３番目の例のように整数型とバイト型をいっしょに宣言しても構いません。


「可変配列」

　配列変数には、可変配列と呼ばれる特殊なものがあります。可変配列は配列のサイ
ズ（要素数）がコンパイル時には決まっておらず、実行時にプログラムによってその
先頭番地とサイズを指定します。可変配列でない普通の配列を固定配列といいます。

　可変配列を作るには、配列を宣言するとき要素数を０として宣言します。そして実
行時に可変配列の先頭番地とサイズを指定するには

　　《先頭番地》 《サイズ（バイト単位）》 ARRAY>> 《配列変数名》

とします。この指定は実行中に何度でも変更できます。

　可変配列の場合、《サイズ》は整数型でもバイト単位で指定しなければならないこ
とに注意してください。たとえば要素数が５個なら１０を指定します。
　これは、私のポリシー（笑）により、可変配列は「要素数がいくつであるか」とい
うことよりも「それがメモリ上でどれだけの空間を占めるか」ということを重視して
いるからです。

　《先頭番地》と《サイズ》はプログラマの責任において指定します。ＭＳＸのシス
テムワークエリアや、プログラム自身と重なる番地を使うと暴走の危険があります。
　一般的にはユーザーフリーエリア（システム変数 _FREE が指す番地から _ENDFREE
が指す番地まで）の中から割り当てます。

　以下に先頭番地とサイズの割り当ての例を挙げます。

	ARRAY( BYTE: N 0  INT: M 0 )

	_FREE        256 ARRAY>> N   /* _FREE から 256バイトを割り当て */
				     /* （要素数２５６） */

	_FREE 256 +  128 ARRAY>> M   /* _FREE+256 から 128バイトを割り当て */
				     /*（要素数６４） */


「ローカル変数」

　ワード定義の外で宣言した変数はグローバル変数と言い、プログラム全体を通して
参照可能です。それに対し、ワード定義の中で宣言した変数はローカル変数と言い、
そのワードの中でのみ参照可能です。ローカル変数は他のワードのローカル変数と名
前がダブっても構いません。

　ローカル変数はメモリ上の固定番地に作られます。つまりＣ言語でいうところの記
憶クラスは static である、ということです。 auto ではありませんので注意してく
ださい。

　以下にローカル変数の例を挙げます。

	VAR( X Y )		/* これはグローバル変数 */
	
	: FUNC_1
	VAR( A B )		/* FUNC_1 の中でのみ有効なローカル変数 */
	
	;
	
	: FUNC_2
	VAR( A B )		/* FUNC_2 の中でのみ有効なローカル変数 */
	
	VAR( X )		/* これはグローバル変数とダブっているので */
				/* エラーになる */
	
	;


「変数のアドレス獲得」

　& 《変数名》

で変数の先頭番地（アドレス）を知ることができます。配列変数の場合配列変数名の
みを書きます。インデックス番号指定はできません
　なお、ワード & は変数だけではなく被コンパイルワードの実行番地の獲得にも使い
ます。


「外部変数の宣言」

　外部変数は

	EXTVAR( 《タイプ》《名前と番地の並び》 )

のように書いて宣言します。《タイプ》は BYTE: か INT: です。《名前と番地の並
び》は

　　《変数名１》 《変数名１の番地》 《変数名２》 《変数名２の番地》・・・

のように書きます。番地は数値定数で書いてください。たとえば、

	EXTVAR( BYTE: CSRY $F3DC  CSRX $F3DD )

と書くと、ＢＩＯＳのワークエリアの CSRX と CSRY （カーソルの位置）があたかも
Ｈ−ＦＯＲＴＨの変数であるかのように使えます。


第３章　被コンパイルワード（能動ワード）

　被コンパイルワードは主にスタック上の数値を操作するワードです。既にシステム
で定義済みのものとユーザーが定義するものがあります

　この章ではシステム定義済み被コンパイルワードのうち、代表的なものについて大
まかに述べます。詳しくはリファレンスガイドを参照してください。また、ＭＳＸ用
に特化されたワードについては第２部で述べます。


「演算系のワード」

+  -  *  /  _/  AND  OR  XOR

　いずれもスタックから数値を２つ取り出し、演算の結果を１つスタックに積むワー
ドです。

例	3 4 + 5 *		結果:	35
	$AAAA $FF OR $F000 XOR	結果:	$5AFF

NEG  CPL  ABS

　スタックから数値を１つ取り出し、演算の結果を１つスタックに積むワードです。

例	100 NEG		結果:	-100
	$AAAA CPL	結果:	$5555


「比較系のワード」

=  <>  <  >  >=  <=  _<  _>  _<=  _>=

　いずれもスタックから２つの数値を取り出して比較し、その条件が成立していれば
１を、成立していなければ０をスタックに積みます。 _ で始まっているワードは数
値を符号無しとみなします。

例	100 10 >	結果:	1
	-1 1 _<		結果:	0　（符号無しとして比較。$FFFF 1 _< と同じ。）


「コンソール系のワード」

.

　スタックから１つ数値を取り出し、それを符号付き数値と見なして画面に１０進で
表示します。

H.

　スタックから１つ数値を取り出し、それを符号無しの数値と見なして画面に１６進
４桁で表示します。

CRLF  SPACE

　それぞれ改行、半角スペースを表示します。

STR.

　スタックから数値を１つ取り出し、それを文字列の先頭番地と見なし、文字コード
 0 が現れるまで画面に表示します。


「メモリ操作系のワード」

C@

　スタックから数値を１つ取り出し、それをメモリの番地としてメモリから１バイト
読み、その値をスタックに積みます。ＢＡＳＩＣの PEEK() に相当します。

C!

　スタックから数値を２つ取り出します。最初に取り出した値をメモリの番地とし、
２番目に取り出した値をその番地に１バイト書き込みます。ＢＡＳＩＣの POKE に相
当します。

@  !

　それぞれ、C@ C! の２バイト版です

例	1 $8000 C!	$8000番地に 1 が書き込まれます。
	$8000 C@	$8000番地を読んでその値をスタックに置きます。
	$1234 $9000 !	$9000番地に $34 が、$9001番地に $12 が書き込まれます。
	$9000 @		$9000番地から２バイト読んでその値をスタックに置きます。

MEMMOVE

　スタックから３つ値を取り出します。最初に取り出した値を転送先の番地、２つめ
に取り出した値を転送するバイト数、３つめに取り出した値を転送元の番地と見なし
てメモリ上で転送を行います。

例	$8000 256 $9000 MEMMOVE		$8000番地から 256バイトを $9000番地に
					転送します。


「文字列操作系のワード」

　Ｈ−ＦＯＲＴＨでは文字列は一番最後に文字コード０が付加されているものとしま
す。最後に０が付加されていない、不完全な文字列に対し文字列操作系のワードを使
用すると、０が見つかるまで止まらないので注意が必要です。
　また、STRMOVE や STRCAT などでは結果の転送先が、文字列を格納するのに十分な
大きさの、書き換えても安全な領域でなければなりません。書き換えても安全な領域
とは、配列変数かユーザーフリーエリアのことです。

STRLEN

　スタックから取り出した値が文字列の先頭番地を指しているものと見なし、その文
字列の長さを調べてスタックに置きます。

例	"ABCDE" STRLEN		結果:	5

STRMOVE

　スタックから２つ値を取り出します。最初に取り出した値を転送先の番地、２つめ
に取り出した値を転送元の文字列の番地と見なして転送を行います。

例	"XYZ" $8000 STRMOVE	文字列 "XYZ" を $8000番地に転送します。

STRCAT

　スタックから２つ値を取り出します。最初に取り出した値が指す文字列を、２つめ
に取り出した値が指す文字列の後ろに転送して結合します。

例	"ABC" $8000 STRMOVE	/* まず $8000番地に "ABC" を転送 */
	$8000 "DEF" STRCAT	/* $8000番地の "ABC" に "DEF" を結合 */
	$8000 STR.		/* 結果表示。 ABCDEF と表示されるはず */


「スタック操作系のワード」

DUP

　スタックの一番上の値を複写してスタックに積みます。たとえば 5 DUP は 5 5 と
同じです。

OVER

　スタックの上から２番目の値を複写してスタックに積みます。たとえば 5 10 OVER
は 5 10 5 と同じです。

SWAP

　スタックの一番上の値と２番目の値を入れ換えます。たとえば 3 4 SWAP は 4 3 と
同じです。

DROP

　スタックの一番上の値を使わずに捨てます。よくある例として、DATA( ) で作ったデ
ータ列の先頭番地のみ必要で総バイト数が不要なとき、これで総バイト数を捨てます。

例	DATA( BYTE: 1 2 3 4 5 ) DROP >> DATA_ADDRESS


第４章　変数操作ワード

　変数操作ワードは、文字どおり変数を操作するワードで、そのワードの次にオペラ
ンドとして操作する変数名を続けます。
　変数操作ワードは、すでに出てきた >> 、ARRAY>> の２つです。


第５章　コンパイラ制御ワード（能動ワード）

　コンパイラ制御ワードは、コンパイラに対し指示を与えます。ワード定義の開始／
終了、変数や定数の宣言などです。今まで出てきた CONST>> とかVAR( とか ARRAY( 
とかもこの範疇に入ります。


「ワードの定義」

　新しいワードを定義するにはワード :  ; を使い、以下のように書きます。

　　: 《新しいワード名》 《定義内容》 ;

また、そのワードがスタックからパラメータを取る場合、ワード PARAM( を使い、

　　: 《新しいワード名》 PARAM( 《パラメータ並び》 ) 《定義内容》 ;

のように書きます。

　《新しいワード名》として既に定義済みのワード名は使えません。また、《定義内
容》の中にに使うことができるワードは定義済みのワードか即値ワードのみです。

　《パラメータ並び》には、取り込むパラメータ変数名を列挙します。すると自動的
にパラメータ変数というローカル変数が作られ、スタックからパラメータ変数に取り
込みが行われます。パラメータ変数は、パラメータの取り込みが行われた後は普通の
ローカル変数と同じなので、代入も可能です。

　例として２つの数値の平均を求めるワードを作って見ます。

	: AVERAGE  PARAM( X Y )  X Y + 2 / ;

AVERAGE が《新しいワード名》です。PARAM( X Y ) からこのワードは２つのパラメ
ータ X と Y をスタックから取り込むことがわかります。X Y + 2 / が《定義内容》
で、「X と Y を足して 2 で割る」ことを意味しています。

　このワードを使って、たとえば 123 と 456 の平均を表示するには、

	123 456 AVERAGE .

と書けばよいのです。

　ワード定義の中に実行制御ワードを含むことも当然可能です。以下の例は 1 から
指定された数までを表示するワードです。実行制御ワードについては後に詳しく述べ
るので、ここでは例を挙げるにとどめます。

	: PRINT_1_N  PARAM( N )
	VAR( I )
	
	1 >> I
	WHILE( I N <= ){
	    I .
	    I 1 + >> I
	}
	;


「コンパイルスイッチ」

　ループ構文において、以下のイベントを検出するかどうか指定します。

　　・ＣＴＲＬ−ＳＴＯＰによるプログラムの中断		BREAKON  BREAKOFF
　　・パラメータスタックのエラー			STKCHKON  STKCHKOFF

　パラメータスタックのエラーとは、スタックオーバーフロー（積み過ぎ）と、ルー
プ中で数値の積み忘れまたは取り忘れ（ループを回るごとにスタックポインタの値が
違う）です。

　これらのワードをソースプログラム中に書くと、それ以降に定義したワードから有
効になります。ワード定義の中には書かないでください。
　いずれもＯＮで検出し、ＯＦＦで検出しません。デフォルトはＯＮです。デバッグ
が終わってからＯＦＦにするとよいでしょう。


「定数データ列」

　プログラム中に定数データ列を置くために、 DATA( というワードがあります。以
下のように使います。

　　DATA( 《データ並び》 )

　《データ並び》の中に書けるのは、即値ワード（文字列も含みます）、 CONST>> で
定義した定数、& 《ワード名》によるワードの番地、そして BYTE: 及び INT: です。
　BYTE: を書くとそれ以降のデータは１バイトサイズとなり、 INT: を書くとそれ以
降のデータは２バイトサイズとなります。

　たとえば、

	DATA( BYTE: $12 $34 $56 INT: 1 2 3 )

は、メモリ上では

	$12 $34 $56 $01 $00 $02 $00 $03 $00

となります。

　DATA( を ) で閉じると、スタックにはまずデータ列の先頭番地が積まれ、続いて
データ列の総バイト数が積まれます。積まれた値はそのまま MEMMOVE や LDIRVM の
パラメータとして使えます。

　また、たとえば

	ARRAY( INT: INIT_DATA 0 )

と可変配列を宣言しておき、以下のようにすれば定数データ列をそっくりそのまま配
列にしてしまうこともできます。

	DATA( INT: 1 2 3 4 5 ) ARRAY>> INIT_DATA

　バージョン１．３より、定数データ列の中にも文字列定数を書くことができるよう
になりました。文字列がそのまま埋め込まれます。
　ただし、定数データ列の中の文字列には末尾の文字コード０が付加されません。こ
れは、場合によっては末尾の０が邪魔になることもあるかも知れないと考えたからで
す。たとえば、長さのわかりきっている文字列をきっちり詰めて書くようなこともあ
るかもしれません。
　末尾の０が必要な場合は、以下のように明示的に文字コード０を入れてください。

	DATA( "STRING DATA\0" )

　定数データ列中の文字列定数は、 INT: ／ BYTE: の状態を変えません。たとえば、

	DATA( INT: 1 2 "ABC" 3 4 )

と書くと、

	$01 $00 $02 $00 $41 $42 $43 $03 $00 $04 $00
	~~~~~~~ ~~~~~~~ ~~~~~~~~~~~ ~~~~~~~ ~~~~~~~
	1       2       "ABC"       3       4

となります。


「メインワード指定」

　ソースプログラムの最後には、

	END  《メインワード名》

を書きます。《メインワード名》とは、コンパイルされたプログラムの中で、一番最
初に実行されるワードです。

　この　END  《メインワード名》　をソースプログラムに書いておかないとＣＯＭ
ファイルは作成されません。


第６章　実行制御ワード

　実行制御ワードは分岐やループなどプログラムの実行の流れを制御するワードです。


「分岐構文」

　条件に応じてプログラムの処理の流れを変えるのが分岐構文です。以下の３つの書
き方があります。

タイプ１　　《条件》 IF{ 《処理》 }

タイプ２　　《条件》 IF{ 《処理１》 }{ 《処理２》 }

タイプ３　　《条件１》 IF{ 《処理１》 }{
	　　《条件２》 IF{ 《処理２》 }|

			：

	　　《条件ｉ》 IF{ 《処理ｉ》 }|

			：

	　　《条件ｎ》 IF{ 《処理ｎ》 }|《処理ｎ＋１》 }


　タイプ１は、《条件》が成立したときのみ《処理》が実行され、成立しなかった場
合《処理》はスキップされます。

　タイプ２は、《条件》が成立したとき《処理１》が実行され、成立しなかった場合
《処理２》が実行されます。

タイプ３は、《条件１》から順に評価され、最初に成立した《条件ｉ》に対応する
《処理ｉ》のみが実行されます。もし《条件１》から《条件ｎ》まですべて成立しな
かった場合、《処理ｎ＋１》が実行されます。《処理》を締めくくっているのが最初
だけ }{ で、２つめ以降は }| 、一番最後が } であることに注意してください。

　分岐構文の例を挙げます。

	X 256 < IF{ X 1 + >> X }

　この例では、変数 X が 256 より小さければ X に１を足します。

	AGE 20 >= IF{
	    "You can drink beer." STR.
	}{
	    "You can't drink beer." STR.
	}

　この例では、変数 AGE が 20 以上なら "You can drink beer." と表示し、そうで
なければ "You can't drink beer." と表示します。

	KEY 'E' = IF{ Y 1 - >> Y }{
	KEY 'S' = IF{ X 1 - >> X }|
	KEY 'D' = IF{ X 1 + >> X }|
	KEY 'X' = IF{ Y 1 + >> Y }|
	}

　この例では、変数 KEY の値に応じて X と Y の値を増減します。


「ループ構文」

　条件が成立している間、処理を繰り返すのがループ構文です。以下の３つの書き方
があります。

タイプ１　　WHILE( 《条件》 ){ 《処理》 }

タイプ２　　{ 《処理》 《条件》 }WHILE

タイプ３　　{ 《処理》 }


　タイプ１は前判断型ループと言い、先に《条件》を評価し、それが成立している間
くり返し《処理》を実行します。最初から《条件》が不成立の場合は《処理》は一度
も実行されません。

　タイプ２は後判断型ループと言い、まず《処理》を実行しその後《条件》を評価し、
成立している間《処理》をくり返し実行します。どんな場合でも少なくとも一度は
《処理》が実行されます。

　タイプ３はいわゆる無限ループで、ひたすら《処理》をくり返します。

　以下に例を挙げます。

	1 >> I			/* I の初期値は 1 */
	WHILE( I N <= ){	/* I が N より小さいか等しい間くり返し */
	    I .			/* I を表示 */
	    I 1 + >> I		/* I に 1 を加える */
	}

この例では、1 から N まで表示します。

	{
	    CHGET >> KEY	/* １文字入力して KEY に代入 */
	    KEY CHPUT		/* KEY の値を１文字出力 */
	    KEY $0D <>		/* KEY の値が $0D(ﾘﾀｰﾝｷｰ)以外ならくり返し */
	}WHILE

　この例では、リターンキーが押されるまで、押されたキーに対応する文字を表示し
つづけます。

	{ '*' CHPUT }

　この例では、ひたすらアスタリスクを表示しつづけます。

　これらのループ構文を実行しているとき、ＣＴＲＬ−ＳＴＯＰが押されると実行を
中断してＤＯＳに戻ります。（ＢＲＥＡＫ許可になっている場合。デフォルトではＢ
ＲＥＡＫ許可になっています。）


「ループ構文補助ワード」

　ループ構文を補助するワードとして CONTINUE と BREAK があります。 CONTINUE 
は、ループの先頭に戻ります。 BREAK はループを抜けます。以下に例を挙げます。

	0 >> I				/* I の初期値 0 */
	WHILE( I 5 < ){			/* I が 5 より小さい間くり返し */
	    CHGET >> KEY		/* １文字入力 */
	    KEY 'A' < IF{ CONTINUE }	/* 'A' より小さければやりなおし */
	    KEY 'Z' > IF{ CONTINUE }	/* 'Z' より大きければやりなおし */
	    
	    KEY CHPUT			/* KEY を１文字出力 */
	    I 1 + >> I			/* I に 1 を加える */
	}

　この例では、アルファベットを５文字入力します。アルファベット以外の文字が入
力されると CONTINUE によってループの先頭に戻ります。


	{
	    "\nHit Y or N : " STR.	/* メッセージ表示 */
	    CHGEY >> KEY		/* １文字入力 */
	    KEY 'Y' = IF{ BREAK }	/* 'Y' ならループを抜ける */
	    KEY 'N' = IF{ BREAK }	/* 'N' ならループを抜ける */
	    '?' CHPUT			/* それ以外なら '?' を表示 */
	}

　この例では、'Y' か 'N' を入力します。１文字入力して 'Y' か 'N' なら BREAK 
によってループを抜けます。それ以外なら '?' を表示して再度入力します。


第７章　第一部のまとめ


　第１部しめくくりの例題です。「エラトステネスのふるい」と呼ばれる方法によって、１から１０００までの素数を求めることにします。

-------------------------------------------------------------- SOSUU.4TH ---

ARRAY( BYTE: MARK 1001 )	/* マーキング用配列 */

/* --- Ｎの倍数のマークを消すワードの定義 --- */

: UNMARK  PARAM( N )		/* ワード名は UNMARK 、パラメータは N */
VAR( I )			/* UNMARK でのみ有効なローカル変数 I */

N 2 * >> I			/* I の初期値は N*2 */
WHILE( I 1000 <= ){		/* I<=1000 の間くり返し */
    FALSE >> MARK [ I ]		/* I番のマークを FALSE （０）にする */
    I N + >> I			/* I に N を足す */
}				/* ループここまで */
;				/* ワード UNMARK の定義終わり */

/* --- メインワードの定義 --- */

: MAIN				/* ワード名は MAIN 、パラメータなし */
VAR( I )			/* MAIN でのみ有効なローカル変数 I */

"\n１から１０００まで素数を求めるぞ！！\n" STR.	/* メッセージ表示 */

1 >> I
WHILE( I 1000 <= ){		/* 1〜1000 まで、 */
    TRUE >> MARK [ I ]		/* MARK をすべて TRUE （１）にする */
    I 1 + >> I
}

2 >> I
WHILE( I 1000 <= ){		/* 2〜1000 まで、 */
    I UNMARK			/* ワード UNMARK を呼び出す */
    I 1 + >> I
}

1 >> I
WHILE( I 1000 <= ){		/* 1〜1000 まで */
    MARK [ I ] IF{ I . }	/* MARK が０でなければ I を表示 */
    I 1 + >> I
}
"\nどうだ！！" STR.		/* 終了メッセージ表示 */
;
END MAIN			/* ソースプログラム終わり、メインワード指定 */

----------------------------------------------------------------------------

